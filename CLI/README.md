## grep 

[Обоснование выбора библиотеки для разбора аргументов](https://docs.google.com/document/d/1M-f-oVbnfAgNSt-xKxVL8P6Tjy-SCB8xaIzTMUswXl0/edit?usp=sharing)

# CLI

## Что это?

Python-скрипт, имитирующий работу интерпретатора командной строки.
Выполняет некоторый поднабор команд средствами языка python,
обращается к системным средствам для выполнения неизвестных команд.
Поддерживает использование переменных окружения, пайпы и два типа кавычек
('', не допускающие подстановки переменных и "", позволяющие это делать).

Реализованные команды:
* echo \[ARGS*\] -- выводит перечисленные аргументы через пробел.
* wc \[FILES*\] -- построчно выводит количество строк, слов и байт в перечисленных файлах.
* pwd -- выводит текущую директорию.
* exit -- выход из приложения.
* cat \[FILES*\] -- выводит содержимое файлов в порядке перечисления. 

### Примеры
    
```>echo " abba ba" | wc```
> 1 2 9

```>pwd```
> /path/to/your/current/dir

```>exit```

(завершение программы)

```
a=exit
$a
```

(завершение программы)




## Как это работает?

Исполнение строчки состоит из двух основных фаз --
разбиение строки на токены и последовательное исполнение найденной последовательности команд.

В зависимости от сожержания строки, её исполнение приведёт либо к добавлению переменной в контекст программы,
либо к исполнению команды и выводу результата её исполнения в stdout.

> Все встречающиеся в процессе токенизации обращения к переменным, лежащие вне одинарных кавычек,
заменяются на значения соответствующих переменных окружения или, если соотвествующая переменная не была найдена, на пустую строку!

> Во время разбиения все подстроки, ограниченные кавычками заменяюся на обособленные ими последостельности символов.

Токенизация происходит следующим образом:

* Если в строке случается присваивание, из строки вычленяются имя переменной,
лежащее слева от знака присваивания и выражение, результат которого будет ей присвоен, лежажее справа.

* В противном случае строка разделяется на последовательность слов, разделённых пробельными символами,
которые группируются в последовательности слов, разделяемые пайпами. После этого первое клово в каждой последовательности считается командой к исполнению, а сопутствующие ей слова -- её аргументами.


### Исполнение команд

Каждая команда в программе описывается как набор соответсвующих ей валидатора, маппера, редьюсера, непосредственного кода команды и коллектора.
При выполнении исполняется следующая последовательность действий:

* Аргументы команды(включая переданные через пайп) передаются на вход валидатору, который определяет корректность входных данных.
* Каждый аргумент(кроме переданного через пайп!), переданный на вход, последовательно проходит через маппер. Результаты исполнения маппера собираются в список.
* Полученный список и аргумент, переданный через пайп, отдаётся на вход редьюсеру.
* Код команды отдельно запускается на каждом элементе списка, который вернул редьюсер.
* На списке результатов исполнения команды запускается коллектор, который превращает полученную последовательность в список строк.

> Указание валидатора, маппера, редьюсера и коллектора является опциональным и первую очередь нужно для
переиспользования частоиспользуемого кода и мимнимизации ответственности, возложенной на класс команды. В случае,
если ни один из них указан не будет, код команды будет обязан принимать список аргументов, переданных на вход, первым
элементом которого будет являться аргумент, переданный через пайп, и возвращать список строк, заканчивающихся на перевод строки.

Непосредственно класс содержит исключительно переменные названий вышеперечисленных компонент и код исполнения.
Вышеуказанная последовательность действий организуется при помощи генерации метода ```exec()``` у класса команды
с помощью метакласса. Метакласс так же регистрирует команду в списке доступных для исполнения команд.

Для более подробного ознакомления можно взглянуть на схему ниже: 

![](https://github.com/annikura/software_design/blob/cli/CLI/workflow_diagram.png?raw=true)